/*
Copyright 2021 Absa Group Limited

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/
package inject

import (
	"context"
	"fmt"
	"gopkg.in/yaml.v3"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/AbsaOSS/golic/utils/log"

	"github.com/denormal/go-gitignore"
	"github.com/enescakir/emoji"
	"github.com/logrusorgru/aurora"
)

type Inject struct {
	opts     Options
	ctx      context.Context
	ignore   gitignore.GitIgnore
	cfg      *Config
	modified int
}

var logger = log.Log

func New(ctx context.Context, options Options) *Inject {
	return &Inject{
		ctx:  ctx,
		opts: options,
	}
}

func (i *Inject) Run() (err error) {
	logger.Info().Msgf("%s reading %s",emoji.OpenBook, i.opts.LicIgnore)
	i.ignore, err = gitignore.NewFromFile(i.opts.LicIgnore)
	if err != nil {
		return err
	}
	logger.Info().Msgf("%s reading %s",emoji.OpenBook, aurora.BrightCyan(i.opts.ConfigURL))
	if i.cfg, err = i.readCommonConfig(); err != nil {
		return
	}
	if _, err = os.Stat(i.opts.ConfigPath); !os.IsNotExist(err) {
		logger.Info().Msgf("%s reading %s",emoji.OpenBook, aurora.BrightCyan(i.opts.ConfigPath))
		logger.Info().Msgf("%s overriding %s with %s",
			emoji.ConstructionWorker, aurora.BrightCyan(i.opts.ConfigURL),aurora.BrightCyan(i.opts.ConfigPath))
		if i.cfg, err = i.readLocalConfig(); err != nil {
			return
		}
	} else {
		logger.Info().Msgf("%s skipping local %s",emoji.FileFolder, aurora.BrightCyan(i.opts.ConfigPath))
		err = nil
	}
	i.traverse()
	return
}

func (i *Inject) String() string {
	return aurora.BrightCyan("inject").String()
}

func (i *Inject) ExitCode() int {
	if i.opts.ModifiedExitStatus && i.modified != 0 {
		return 1
	}
	return 0
}

func read(f string) (s string, err error) {
	content, err := ioutil.ReadFile(f)
	if err != nil {
		return
	}
	// Convert []byte to string and print to screen
	return string(content), nil
}

func (i *Inject) traverse() {
	skipped := 0
	visited := 0
	p := func(path string, i gitignore.GitIgnore, o Options, config *Config) (err error) {
		if !i.Ignore(path) {
			var skip bool
			symbol := ""
			visited++
			if err,skip  = inject(path,o, config); skip {
				symbol = "-> skip"
				skipped++
			}
			emoji.Printf(" %s  %s %s  \n",emoji.Minus, aurora.BrightYellow(path), aurora.BrightMagenta(symbol))
		}
		return
	}

	err := filepath.Walk("./",
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() {
				return p(path, i.ignore, i.opts, i.cfg)
			}
			return nil
		})
	if err != nil {
		logger.Err(err).Msg("")
	}
	i.modified = visited - skipped
	summary(skipped,visited)
}


func summary(skipped, visited int) {
	if skipped == visited {
		fmt.Printf("\n %s %v/%v %s\n\n", emoji.Ice, aurora.BrightCyan(visited-skipped), aurora.BrightWhite(visited), aurora.BrightBlue("changed"))
		return
	}
	fmt.Printf("\n %s %v/%v %s\n\n", emoji.Fire, aurora.BrightMagenta(visited-skipped), aurora.BrightWhite(visited), aurora.BrightYellow("changed"))
}

func inject(path string, o Options, config *Config) (err error, skip bool) {
	source,err := read(path)
	if err != nil {
		return err,false
	}
	rule := getRule(path)
	license,err := getCommentedLicense(config, o, rule)
	if err != nil {
		return err, false
	}
	if config.LicenseStartsAfterHeader(rule) {
		// gets first line of source and the rest of source code
		l1, lx := splitSource(source)
		// file is not empty and file contains header
		if  headerContains(l1, config.Golic.Rules[rule].Under) {
			license = fmt.Sprintf("%s\n%s", l1, license)
			if strings.HasPrefix(source, license) {
				return nil, true
			}
			source = lx
		}
	}
	if strings.HasPrefix(source, license) {
		return nil, true
	}
	if !o.Dry {
		data := []byte(fmt.Sprintf("%s%s", license, source))
		err = ioutil.WriteFile(path,data, os.ModeExclusive)
	}
	return
}

func headerContains(header string, values []string) bool{
	for _,v := range values {
		if strings.Contains(header, v) {
			return true
		}
	}
	return false
}

func matchRule(config *Config, fileName string) (rule string, ok bool) {
	if _, ok = config.Golic.Rules[fileName]; ok {
		return fileName, ok
	}
	// if rule is pattern like Dockerfile*
	for k := range config.Golic.Rules {
		matched, _ := filepath.Match(k, fileName)
		if matched {
			return k, true
		}
	}
	return
}

func getCommentedLicense(config *Config, o Options, file string) (string, error) {
	var ok bool
	var template string
	var rule string
	if template, ok = config.Golic.Licenses[o.Template]; !ok {
		return "",fmt.Errorf("no license found for %s, check configuration (%s)",o.Template,o.ConfigURL)
	}
	//if _, ok =  config.Golic.Rules[rule]; !ok {
	if rule, ok =  matchRule(config, file); !ok {
		return "",fmt.Errorf("no rule found for %s, check configuration (%s)", rule,o.ConfigURL)
	}
	template = strings.ReplaceAll(template,"{{copyright}}", o.Copyright)
	if config.IsWrapped(rule) {
		return fmt.Sprintf("%s\n%s%s\n",
			config.Golic.Rules[rule].Prefix,
			template,
			config.Golic.Rules[rule].Suffix),
			nil
	}
	// `\r\n` -> `\r\n #`, `\n` -> `\n #`
	var indent string
	switch config.Golic.Rules[rule].Indent {
	case "NO_INDENT": indent = ""
	case "":  indent = " "
	default: indent = config.Golic.Rules[rule].Indent
	}

	content := strings.ReplaceAll(template,"\n",fmt.Sprintf("\n%s%s", config.Golic.Rules[rule].Prefix,indent))
	content = strings.TrimSuffix(content, config.Golic.Rules[rule].Prefix+indent)
	content = config.Golic.Rules[rule].Prefix + indent + content
	// "# \n" -> "#\n" // "# \r\n" -> "#\r\n"; some environments automatically remove spaces in empty lines. This makes problems in license PR's
	content = strings.ReplaceAll(content,fmt.Sprintf("%s \n",config.Golic.Rules[rule].Prefix),fmt.Sprintf("%s\n",config.Golic.Rules[rule].Prefix))
	content = strings.ReplaceAll(content,fmt.Sprintf("%s \r\n",config.Golic.Rules[rule].Prefix),fmt.Sprintf("%s\r\n",config.Golic.Rules[rule].Prefix))
	return content,nil
}

func splitSource(source string) (firstLine, rest string){
	lines := strings.Split(source,"\n")
	if len(lines) > 0 {
		firstLine = lines[0]
		rest = strings.Join(lines[1:],"\n")
		return
	}
	return "",source
}

func getRule(path string) (rule string) {
	rule = filepath.Ext(path)
	if rule == "" {
		rule = filepath.Base(path)
	}
	return
}

func (i *Inject) readLocalConfig() (*Config, error) {
	var c = &Config{}
	var rc = *i.cfg
	yamlFile, err := ioutil.ReadFile(i.opts.ConfigPath)
	if err != nil {
		return nil,nil
	}
	err = yaml.Unmarshal(yamlFile, c)
	if err != nil {
		return nil,nil
	}
	for k,v := range c.Golic.Licenses {
		rc.Golic.Licenses[k] = v
	}
	for k,v := range c.Golic.Rules {
		rc.Golic.Rules[k] = v
	}
	return &rc,nil
}

func (i *Inject) readCommonConfig() (c *Config, err error) {
	var client http.Client
	var resp *http.Response
	var b []byte
	c = new(Config)
	resp, err = client.Get(i.opts.ConfigURL)
	if err != nil {
		return
	}
	if resp.StatusCode >= http.StatusBadRequest {
		return nil, fmt.Errorf("%s: %s returns %d", http.MethodGet, i.opts.ConfigURL, resp.StatusCode)
	}
	defer resp.Body.Close()
	if b, err = ioutil.ReadAll(resp.Body); err != nil {
		return
	}
	err = yaml.Unmarshal(b, c)
	return
}